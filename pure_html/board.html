<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Transcript Annotation Board</title>
  <style>
    * { box-sizing: border-box; }
    body{
      margin:0;
      height:100vh;
      display:flex;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      background:#f5f5f5;
      overflow:hidden;
    }

    .sidebar{
      width:280px;
      background:#2c3e50;
      color:#fff;
      padding:16px;
      overflow:auto;
      border-right:2px solid #34495e;
    }
    .sidebar h2{
      margin:0 0 12px 0;
      font-size:16px;
      border-bottom:2px solid #34495e;
      padding-bottom:10px;
    }
    .hint{
      font-size:12px;
      color:rgba(255,255,255,0.8);
      line-height:1.4;
      margin-bottom:12px;
    }
    .category-list{ display:flex; flex-direction:column; gap:8px; }
    .category-item{
      padding:10px 10px;
      border-radius:8px;
      cursor:pointer;
      background:#34495e;
      transition:0.15s;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    .category-item:hover{ background:#4a5f7a; }
    .category-item.active{ background:#3498db; }
    .category-name{ font-size:12px; font-weight:700; line-height:1.2; word-break:break-word; }
    .badge{
      font-size:11px;
      padding:2px 7px;
      border-radius:999px;
      background:rgba(255,255,255,0.15);
      flex-shrink:0;
    }

    .main{ flex:1; display:flex; flex-direction:column; min-width:0; }
    .topbar{
      height:54px;
      background:#fff;
      border-bottom:1px solid #e6e6e6;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:0 14px;
      gap:10px;
      flex-shrink:0;
    }
    .topbar-left{ display:flex; align-items:baseline; gap:12px; min-width:0; }
    .title{ font-size:14px; font-weight:800; color:#2c3e50; white-space:nowrap; }
    .subtitle{
      font-size:12px;
      color:#6c757d;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width:60vw;
    }
    .topbar-actions{ display:flex; gap:8px; align-items:center; flex-shrink:0; }
    .btn{
      border:0;
      border-radius:8px;
      padding:8px 10px;
      cursor:pointer;
      font-size:12px;
      user-select:none;
    }
    .btn-secondary{ background:#ecf0f1; color:#2c3e50; }
    .btn-danger{ background:#ffecec; color:#c0392b; }

    .board-wrap{
      position:relative;
      flex:1;
      overflow:auto;
      background:
        radial-gradient(circle at 1px 1px, rgba(0,0,0,0.06) 1px, transparent 0) 0 0/20px 20px,
        #fbfbfb;
    }

    .board{
      position:relative;
      width:6000px;
      height:4000px;
      transform-origin:0 0;
    }

    .card{
      position:absolute;
      width:260px;
      background:rgba(179,224,255,0.42);
      border:1px solid #3498db;
      border-radius:12px;
      box-shadow:0 8px 20px rgba(0,0,0,0.12);
      padding:10px 10px 8px 10px;
      cursor:grab;
      user-select:none;
      touch-action:none;
    }
    .card:active{ cursor:grabbing; }

    .card-header{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:8px;
      margin-bottom:6px;
      position:relative;
    }
    .card-title{
      font-size:13px;
      font-weight:800;
      color:#043a85;
      line-height:1.2;
      flex:1;
      word-break:break-word;
      outline:none;
    }

    .card-actions{
      display:flex;
      gap:6px;
      flex-shrink:0;
      align-items:center;

      opacity:0;
      pointer-events:none;
      transform: translateY(-2px);
      transition: 0.12s ease;
    }
    .card:hover .card-actions,
    .card:focus-within .card-actions{
      opacity:1;
      pointer-events:auto;
      transform: translateY(0);
    }

    .icon-btn{
      width:26px;
      height:26px;
      border-radius:8px;
      border:0;
      cursor:pointer;
      background:rgba(255,255,255,0.6);
      display:grid;
      place-items:center;
      color:#2c3e50;
    }
    .icon-btn:hover{ background:rgba(255,255,255,0.9); }

    .toggle-wrap{
      position:relative;
      margin-top:6px;
      border-radius:10px;
      outline:none;
      cursor:pointer;
    }

    .caret-mini{
      position:absolute;
      top:6px;
      right:8px;
      width:20px;
      height:20px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.70);
      color:#2c3e50;
      display:grid;
      place-items:center;
      font-size:12px;
      line-height:1;
      cursor:pointer;
      user-select:none;

      opacity:0;
      transform: translateY(-2px);
      transition: 0.12s ease;
      pointer-events:none;
    }

    .toggle-wrap:hover .caret-mini,
    .toggle-wrap:focus-within .caret-mini{
      opacity:1;
      transform: translateY(0);
      pointer-events:auto;
    }

    .card-body, .card-quote{
      font-size:12px;
      line-height:1.45;
      white-space:pre-wrap;
      word-break:break-word;
      user-select:text;
      cursor:text;
      outline:none;
      border-radius:10px;
      padding:8px;
      min-width:0;
    }

    .card-body{
      color:#043a85;
      background:rgba(255,255,255,0.35);
      border:1px solid rgba(52,152,219,0.25);
      min-height:28px;
    }
    .card-quote{
      color:#2c3e50;
      background:rgba(255,255,255,0.55);
      border:1px dashed rgba(44,62,80,0.25);
      min-height:28px;
    }

    .collapsed-one-line{
      white-space:nowrap !important;
      overflow:hidden !important;
      text-overflow:ellipsis !important;
      min-height:unset !important;
    }

    .card-meta{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin-top:8px;
      font-size:10px;
      color:#6c757d;
      font-style:italic;
      align-items:flex-end;
    }

    .meta-right{
      display:flex;
      gap:6px;
      align-items:center;
      flex-shrink:0;
    }
    .tag-select{
      font-style:normal;
      font-size:10px;
      line-height:1;
      padding:2px 6px;
      height:18px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,0.14);
      background: rgba(255,255,255,0.75);
      color:#2c3e50;
      outline:none;
      cursor:pointer;
    }
    .tag-select:focus{
      border-color: rgba(52,152,219,0.55);
      box-shadow: 0 0 0 2px rgba(52,152,219,0.12);
    }

    .text-block{
      position:absolute;
      width:260px;
      background:rgba(255,255,255,0.85);
      border:1px solid rgba(0,0,0,0.12);
      border-radius:12px;
      box-shadow:0 8px 20px rgba(0,0,0,0.10);
      padding:10px;
      cursor:grab;
      user-select:none;
      touch-action:none;
    }
    .text-block:active{ cursor:grabbing; }
    .text-block .text{
      font-size:12px;
      color:#2c3e50;
      line-height:1.45;
      white-space:pre-wrap;
      word-break:break-word;
      user-select:text;
      cursor:text;
      outline:none;
    }

    .text-block.tb-yellow { background: rgba(255, 249, 196, 0.92); }
    .text-block.tb-pink   { background: rgba(255, 224, 235, 0.92); }
    .text-block.tb-blue   { background: rgba(220, 238, 255, 0.92); }
    .text-block.tb-green  { background: rgba(221, 255, 228, 0.92); }

        /* ---- Text block color dots ---- */
    .tb-colorbar{
    display:flex;
    gap:6px;
    align-items:center;
    padding:2px 6px;
    border-radius:999px;
    background: rgba(255,255,255,0.55);
    border: 1px solid rgba(0,0,0,0.10);
    }

    .tb-dot{
    width:12px;
    height:12px;
    border-radius:999px;
    border:1px solid rgba(0,0,0,0.18);
    cursor:pointer;
    display:inline-block;
    position:relative;
    }
    .tb-dot:hover{ transform: translateY(-1px); }

    .tb-dot.active{
    outline: 2px solid rgba(52,152,219,0.85);
    outline-offset: 1px;
    }

    /* dot colors */
    .tb-dot[data-color=""]{ background: rgba(245,245,245,0.9); } /* default */
    .tb-dot[data-color="tb-yellow"]{ background: rgba(255, 244, 170, 0.95); }
    .tb-dot[data-color="tb-pink"]{ background: rgba(255, 200, 220, 0.95); }
    .tb-dot[data-color="tb-blue"]{ background: rgba(198, 227, 255, 0.95); }
    .tb-dot[data-color="tb-green"]{ background: rgba(200, 255, 214, 0.95); }

    /* ---- Text block: hover-only actions (color dots + trash) ---- */
    .text-block .tb-actions{
    display:flex;
    gap:8px;
    align-items:center;

    opacity:0;
    pointer-events:none;
    transform: translateY(-2px);
    transition: 0.12s ease;
    }

    /* show actions when hover, selected, or focus within (editing) */
    .text-block:hover .tb-actions,
    .text-block.selected .tb-actions,
    .text-block:focus-within .tb-actions{
    opacity:1;
    pointer-events:auto;
    transform: translateY(0);
    }

    /* keep header compact */
    .text-block .tb-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:10px;
    margin-bottom:8px;
    }

    .selected{
      outline: 2px solid rgba(52,152,219,0.95);
      box-shadow: 0 0 0 3px rgba(52,152,219,0.15), 0 8px 20px rgba(0,0,0,0.12);
    }

    .marquee{
      position:absolute;
      border:1px dashed rgba(52,152,219,0.95);
      background: rgba(52,152,219,0.12);
      pointer-events:none;
      z-index: 9999;
      border-radius: 8px;
    }

    .empty{ padding:18px; color:#6c757d; font-size:12px; }
  </style>
</head>
<body>
  <aside class="sidebar">
    <h2>Categories</h2>
    <div class="hint">for better labeling :D</div>
    <div class="category-list" id="categoryList">
      <div class="empty">Loading categoriesâ€¦</div>
    </div>
  </aside>

  <main class="main">
    <div class="topbar">
      <div class="topbar-left">
        <div class="title">Annotation Board</div>
        <div class="subtitle" id="subtitle">No category selected</div>
      </div>
      <div class="topbar-actions">
        <button class="btn btn-secondary" id="btnAddText">+ Text block</button>
        <button class="btn btn-secondary" id="btnSaveLayout">Save layout</button>
        <button class="btn btn-danger" id="btnClearLocal">Clear local layout</button>
      </div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <div class="board" id="board"></div>
    </div>
  </main>

  <script>
    const CONFIG = {
      categoriesUrl: "../server/annotations/categories.json",
      annotationsBase: "../server/annotations",


      segmentedBase: "../server/segmented",
      segmentFiles: [0,1,2,3,4],

      defaultPX_X: 120,
      defaultPX_Y: 120,
      cascadeStep: 28,
      legacyScale: 400
    };
    const TB_COLOR_CLASSES = ["tb-yellow", "tb-pink", "tb-blue", "tb-green"];

    function applyTextBlockColor(el, colorClass) {
    TB_COLOR_CLASSES.forEach(c => el.classList.remove(c));
    if (TB_COLOR_CLASSES.includes(colorClass)) el.classList.add(colorClass);
    }
    const els = {
      categoryList: document.getElementById("categoryList"),
      board: document.getElementById("board"),
      subtitle: document.getElementById("subtitle"),
      btnAddText: document.getElementById("btnAddText"),
      btnSaveLayout: document.getElementById("btnSaveLayout"),
      btnClearLocal: document.getElementById("btnClearLocal"),
      boardWrap: document.getElementById("boardWrap"),
    };

    let categories = [];
    let activeCategory = null;

    const transcriptCache = new Map();


    const segmentCache = new Map();


    const ORIGINAL_TO_PREF = {
      // Male
      Ian: "Cars",
      Sebastian: "Cars",
      Ezekiel: "Cars",
      Ederson: "Cars",
      Chris: "Cars",
      Advait: "Cars",
      Malik: "Cars",
      Crosby: "Movies",
      Jian: "Movies",
      Hailey: "Movies",
      Jacob: "Movies",
      Atharva: "Movies",
      Shay: "Movies",
      Ronny: "Movies",
      Jaylon: "Movies",
      // Female
      Sage: "Cars",
      Shasha: "Cars",
      Sarah: "Cars",
      Alex: "Cars",
      Esther: "Cars",
      Maria: "Movies",
      Ina: "Movies",
      Zoe: "Movies",
    };

    const ORIGINAL_TO_ANON = {
      Esther: "Maya",
      Malik: "Oliver",
      Jaylon: "Serena",
      Ronny: "Devin",
      Chris: "Lina",
      Zoe: "Jasper",
      Advait: "Naomi",
      Shay: "Theo",
      Alex: "Carmen",
      Atharva: "Felix",
      Jacob: "Aria",
      Ederson: "Marcus",
      Ina: "Tessa",
      Sebastian: "Gabriel",
      Ian: "Rhea",
      Maria: "Daniel",
      Jian: "Ivy",
      Sarah: "Victor",
      Crosby: "Elinor",
      Sage: "Nolan",
    };

    function prefToTag1(pref) {
      if (pref === "Movies") return "M";
      if (pref === "Cars") return "C";
      return "-";
    }


    function numToRoman(n){
      const map = {1:"I",2:"II",3:"III",4:"IV"};
      return map[n] || "-";
    }

    function getAnchorMessageIndex(ann){
      const arr = ann?.messageIndices;
      if (Array.isArray(arr) && arr.length > 0) {

        const nums = arr.map(Number).filter(Number.isFinite);
        if (nums.length) return Math.min(...nums);
      }
      return null;
    }


    function getSegmentKForMessageIndex(transcriptFile, messageIndex){
      const ranges = segmentCache.get(transcriptFile);
      if (!ranges || messageIndex === null) return null;

      for (const r of ranges) {
        if (Number.isFinite(r.start) && Number.isFinite(r.end)) {
          if (messageIndex >= r.start && messageIndex <= r.end) return r.k;
        }
      }
      return null;
    }

    function getTag2FromAnnotationBySegment(transcriptFile, ann){
      const mi = getAnchorMessageIndex(ann);
      const k = getSegmentKForMessageIndex(transcriptFile, mi);

      // k=0 is Introduction -> '-'
      if (k === 1 || k === 2 || k === 3 || k === 4) return numToRoman(k);
      return "-";
    }

    // Tag1 preset by transcript file; Tag2 preset by segment mapping
    function getPresetFor(transcriptFile, ann) {
      const tf = String(transcriptFile || "").trim();
      let tag1 = "-";
      if (tf) {
        for (const [orig, anon] of Object.entries(ORIGINAL_TO_ANON)) {
          if (anon === tf) {
            tag1 = prefToTag1(ORIGINAL_TO_PREF[orig]);
            break;
          }
        }
      }
      const tag2 = getTag2FromAnnotationBySegment(tf, ann);
      return { tag1, tag2 };
    }

    // Selection state
    const selection = {
      keys: new Set(),
      marqueeEl: null,
      isMarquee: false,
      marqueeStart: null,
      isGroupDrag: false,
      groupStart: null,
      originalPositions: new Map()
    };

    const dragState = { el: null, startX: 0, startY: 0, originX: 0, originY: 0, pointerId: null };

    function lsKeyForCategory(categoryLabel) { return `board_layout__${categoryLabel}`; }

    function escapeHtml(text) {
      const div = document.createElement("div");
      div.textContent = String(text ?? "");
      return div.innerHTML;
    }

    async function fetchJson(url) {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`${res.status} ${res.statusText} (${url})`);
      return await res.json();
    }

    async function loadCategories() {
      categories = await fetchJson(CONFIG.categoriesUrl);
      renderCategoryList();
    }

    function renderCategoryList() {
      els.categoryList.innerHTML = "";
      if (!Array.isArray(categories) || categories.length === 0) {
        els.categoryList.innerHTML = `<div class="empty">No categories found.</div>`;
        return;
      }

      categories.forEach((c) => {
        const item = document.createElement("div");
        item.className = "category-item";
        item.dataset.label = c.label;

        const count = Array.isArray(c.annotations) ? c.annotations.length : 0;

        item.innerHTML = `
          <div class="category-name">${escapeHtml(c.label)}</div>
          <div class="badge">${count}</div>
        `;
        item.addEventListener("click", () => selectCategory(c.label));
        els.categoryList.appendChild(item);
      });
    }

    function setActiveCategoryUI(label) {
      document.querySelectorAll(".category-item").forEach((el) => {
        el.classList.toggle("active", el.dataset.label === label);
      });
    }

    async function loadTranscriptFile(transcriptFile) {
      if (transcriptCache.has(transcriptFile)) return transcriptCache.get(transcriptFile);
      const url = `${CONFIG.annotationsBase}/${encodeURIComponent(transcriptFile)}.json`;
      const data = await fetchJson(url);
      transcriptCache.set(transcriptFile, data);
      return data;
    }

    async function loadSegmentRanges(transcriptFile){
      const tf = String(transcriptFile || "").trim();
      if (!tf) return [];
      if (segmentCache.has(tf)) return segmentCache.get(tf);

      const ranges = [];
      await Promise.all(CONFIG.segmentFiles.map(async (k) => {
        const url = `${CONFIG.segmentedBase}/${encodeURIComponent(tf)}/${k}.json`;
        try{
          const data = await fetchJson(url);
          const start = Number(data?.start_index);
          const end = Number(data?.end_index);
          ranges.push({
            k,
            start: Number.isFinite(start) ? start : null,
            end: Number.isFinite(end) ? end : null,
            title: data?.title ?? ""
          });
        } catch(e){
          // if missing, just skip. (but warn so you can see path issues)
          console.warn("Missing segmented file:", url, e);
        }
      }));

      // sort by k asc (0..4)
      ranges.sort((a,b) => a.k - b.k);
      segmentCache.set(tf, ranges);
      return ranges;
    }

    async function selectCategory(label) {
      activeCategory = categories.find((c) => c.label === label) || null;
      setActiveCategoryUI(label);

      els.subtitle.textContent = activeCategory
        ? `${activeCategory.label} (${(activeCategory.annotations || []).length} annotations)`
        : "No category selected";

      clearSelection();
      await renderBoardForActiveCategory();
    }

    function clearBoard() { els.board.innerHTML = ""; }

    function loadLayoutFromLocal(categoryLabel) {
      try {
        const raw = localStorage.getItem(lsKeyForCategory(categoryLabel));
        if (!raw) return null;
        return JSON.parse(raw);
      } catch { return null; }
    }

    function saveLayoutToLocal(categoryLabel, layout) {
      try { localStorage.setItem(lsKeyForCategory(categoryLabel), JSON.stringify(layout)); }
      catch (e) { console.warn("Failed to save layout:", e); }
    }

    function upsertLocalItem(categoryLabel, itemKey, partial) {
      const layout = loadLayoutFromLocal(categoryLabel) || { items: {}, textBlocks: {} };
      layout.items = layout.items || {};
      layout.textBlocks = layout.textBlocks || {};

      if (itemKey.startsWith("tb__")) {
        layout.textBlocks[itemKey] = { ...(layout.textBlocks[itemKey] || {}), ...partial };
      } else {
        layout.items[itemKey] = { ...(layout.items[itemKey] || {}), ...partial };
      }
      saveLayoutToLocal(categoryLabel, layout);
    }

    function removeLocalItem(categoryLabel, itemKey) {
      const layout = loadLayoutFromLocal(categoryLabel) || { items: {}, textBlocks: {} };
      layout.items = layout.items || {};
      layout.textBlocks = layout.textBlocks || {};
      if (itemKey.startsWith("tb__")) delete layout.textBlocks[itemKey];
      else delete layout.items[itemKey];
      saveLayoutToLocal(categoryLabel, layout);
    }

    function toPXMaybe(value, fallbackPX) {
      if (value === null || value === undefined || Number.isNaN(Number(value))) return fallbackPX;
      const v = Number(value);
      if (Math.abs(v) <= 2.5) return v * CONFIG.legacyScale;
      return v;
    }

    function isMoreThanOneLine(el) {
      const cs = window.getComputedStyle(el);
      const lh = parseFloat(cs.lineHeight) || 16;
      return el.scrollHeight > lh * 1.6;
    }

    function setCollapsed(wrapperEl, contentEl, caretBtn, collapsed) {
      if (!wrapperEl || !contentEl) return;
      wrapperEl.dataset.collapsed = collapsed ? "1" : "0";
      contentEl.classList.toggle("collapsed-one-line", !!collapsed);
      if (caretBtn) caretBtn.textContent = collapsed ? "â–¶" : "â–¼";
    }

    function shouldToggleFromClick(e, contentEl) {
      const clickedEditable = (e.target === contentEl) || (e.target?.isContentEditable);
      if (clickedEditable) return false;
      if (e.altKey) return true;
      return true;
    }

    function wireToggle(wrapperEl, contentEl, caretBtn, itemKey, fieldName) {
      if (!wrapperEl || !contentEl) return;

      wrapperEl.addEventListener("click", (e) => {
        if (!activeCategory) return;
        if (e.target?.closest(".caret-mini")) return;
        if (!shouldToggleFromClick(e, contentEl)) return;

        const collapsed = wrapperEl.dataset.collapsed === "1";
        const next = !collapsed;
        setCollapsed(wrapperEl, contentEl, caretBtn, next);
        upsertLocalItem(activeCategory.label, itemKey, { [fieldName]: next });
      });

      caretBtn?.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!activeCategory) return;
        const collapsed = wrapperEl.dataset.collapsed === "1";
        const next = !collapsed;
        setCollapsed(wrapperEl, contentEl, caretBtn, next);
        upsertLocalItem(activeCategory.label, itemKey, { [fieldName]: next });
      });
    }

    function getBoardPointFromClient(clientX, clientY) {
      const boardRect = els.board.getBoundingClientRect();
      return { x: clientX - boardRect.left, y: clientY - boardRect.top };
    }

    function rectFromPoints(a, b) {
      const left = Math.min(a.x, b.x);
      const top = Math.min(a.y, b.y);
      const right = Math.max(a.x, b.x);
      const bottom = Math.max(a.y, b.y);
      return { left, top, right, bottom, width: right - left, height: bottom - top };
    }

    function getElementRectInBoard(el) {
      const x = parseFloat(el.style.left || "0");
      const y = parseFloat(el.style.top || "0");
      const w = el.offsetWidth;
      const h = el.offsetHeight;
      return { left: x, top: y, right: x + w, bottom: y + h };
    }

    function rectsIntersect(a, b) {
      return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
    }

    function applySelectionUI() {
      els.board.querySelectorAll(".card, .text-block").forEach((el) => {
        const key = el.dataset.key;
        el.classList.toggle("selected", selection.keys.has(key));
      });
    }

    function clearSelection() {
      selection.keys.clear();
      applySelectionUI();
    }

    function toggleSelectionKey(key) {
      if (selection.keys.has(key)) selection.keys.delete(key);
      else selection.keys.add(key);
      applySelectionUI();
    }

    function setSingleSelection(key) {
      selection.keys.clear();
      selection.keys.add(key);
      applySelectionUI();
    }

    function startMarquee(e) {
      if (e.button !== 0) return;
      selection.isMarquee = true;

      const p = getBoardPointFromClient(e.clientX, e.clientY);
      selection.marqueeStart = p;

      if (!e.shiftKey) clearSelection();

      const el = document.createElement("div");
      el.className = "marquee";
      el.style.left = `${p.x}px`;
      el.style.top = `${p.y}px`;
      el.style.width = `0px`;
      el.style.height = `0px`;
      els.board.appendChild(el);
      selection.marqueeEl = el;
    }

    function updateMarquee(e) {
      if (!selection.isMarquee || !selection.marqueeEl) return;
      const p = getBoardPointFromClient(e.clientX, e.clientY);
      const r = rectFromPoints(selection.marqueeStart, p);

      selection.marqueeEl.style.left = `${r.left}px`;
      selection.marqueeEl.style.top = `${r.top}px`;
      selection.marqueeEl.style.width = `${r.width}px`;
      selection.marqueeEl.style.height = `${r.height}px`;

      const marqueeRect = { left: r.left, top: r.top, right: r.right, bottom: r.bottom };

      els.board.querySelectorAll(".card, .text-block").forEach((item) => {
        const key = item.dataset.key;
        const itemRect = getElementRectInBoard(item);
        if (rectsIntersect(marqueeRect, itemRect)) selection.keys.add(key);
      });

      applySelectionUI();
    }

    function endMarquee() {
      selection.isMarquee = false;
      selection.marqueeStart = null;
      if (selection.marqueeEl) {
        selection.marqueeEl.remove();
        selection.marqueeEl = null;
      }
    }

    function startGroupDrag(e, grabbedEl) {
      selection.isGroupDrag = true;
      selection.groupStart = { x: e.clientX, y: e.clientY };
      selection.originalPositions.clear();

      selection.keys.forEach((key) => {
        const el = els.board.querySelector(`[data-key="${CSS.escape(key)}"]`);
        if (!el) return;
        selection.originalPositions.set(key, {
          x: parseFloat(el.style.left || "0"),
          y: parseFloat(el.style.top || "0")
        });
      });

      grabbedEl.setPointerCapture(e.pointerId);
      dragState.el = grabbedEl;
      dragState.pointerId = e.pointerId;

      grabbedEl.addEventListener("pointermove", onGroupDragMove);
      grabbedEl.addEventListener("pointerup", onGroupDragEnd);
      grabbedEl.addEventListener("pointercancel", onGroupDragEnd);
    }

    function onGroupDragMove(e) {
      if (!selection.isGroupDrag || e.pointerId !== dragState.pointerId) return;

      const dx = e.clientX - selection.groupStart.x;
      const dy = e.clientY - selection.groupStart.y;

      selection.originalPositions.forEach((pos, key) => {
        const el = els.board.querySelector(`[data-key="${CSS.escape(key)}"]`);
        if (!el) return;
        el.style.left = `${pos.x + dx}px`;
        el.style.top  = `${pos.y + dy}px`;
      });
    }

    function onGroupDragEnd(e) {
      if (!selection.isGroupDrag || e.pointerId !== dragState.pointerId) return;

      const grabbedEl = dragState.el;
      try { grabbedEl.releasePointerCapture(dragState.pointerId); } catch {}

      grabbedEl.removeEventListener("pointermove", onGroupDragMove);
      grabbedEl.removeEventListener("pointerup", onGroupDragEnd);
      grabbedEl.removeEventListener("pointercancel", onGroupDragEnd);

      if (activeCategory) {
        selection.keys.forEach((key) => {
          const el = els.board.querySelector(`[data-key="${CSS.escape(key)}"]`);
          if (!el) return;
          const x = parseFloat(el.style.left || "0");
          const y = parseFloat(el.style.top || "0");
          upsertLocalItem(activeCategory.label, key, { x, y });
        });
      }

      selection.isGroupDrag = false;
      selection.groupStart = null;
      selection.originalPositions.clear();

      dragState.el = null;
      dragState.pointerId = null;
    }

    function startSingleDrag(e, el) {
      el.setPointerCapture(e.pointerId);
      dragState.el = el;
      dragState.pointerId = e.pointerId;
      dragState.startX = e.clientX;
      dragState.startY = e.clientY;
      dragState.originX = parseFloat(el.style.left || "0");
      dragState.originY = parseFloat(el.style.top || "0");

      el.addEventListener("pointermove", onSingleDragMove);
      el.addEventListener("pointerup", onSingleDragEnd);
      el.addEventListener("pointercancel", onSingleDragEnd);
    }

    function onSingleDragMove(e) {
      if (!dragState.el || e.pointerId !== dragState.pointerId) return;

      const dx = e.clientX - dragState.startX;
      const dy = e.clientY - dragState.startY;

      dragState.el.style.left = `${dragState.originX + dx}px`;
      dragState.el.style.top  = `${dragState.originY + dy}px`;
    }

    function onSingleDragEnd(e) {
      if (!dragState.el || e.pointerId !== dragState.pointerId) return;

      const el = dragState.el;
      try { el.releasePointerCapture(dragState.pointerId); } catch {}

      el.removeEventListener("pointermove", onSingleDragMove);
      el.removeEventListener("pointerup", onSingleDragEnd);
      el.removeEventListener("pointercancel", onSingleDragEnd);

      if (activeCategory) {
        const key = el.dataset.key;
        const x = parseFloat(el.style.left || "0");
        const y = parseFloat(el.style.top || "0");
        upsertLocalItem(activeCategory.label, key, { x, y });
      }

      dragState.el = null;
      dragState.pointerId = null;
    }

    async function renderBoardForActiveCategory() {
      clearBoard();
      if (!activeCategory) return;

      const assignments = Array.isArray(activeCategory.annotations) ? activeCategory.annotations : [];
      if (assignments.length === 0) {
        els.board.innerHTML = `<div class="empty">This category has no annotations.</div>`;
        return;
      }

      const layout = loadLayoutFromLocal(activeCategory.label) || { items: {}, textBlocks: {} };
      const itemLayout = layout.items || {};
      const textLayout = layout.textBlocks || {};

      const byTranscript = new Map();
      for (const a of assignments) {
        if (!a || !a.transcriptFile) continue;
        if (!byTranscript.has(a.transcriptFile)) byTranscript.set(a.transcriptFile, []);
        byTranscript.get(a.transcriptFile).push(a.annotationId);
      }

      const transcriptNames = Array.from(byTranscript.keys());


      await Promise.all(transcriptNames.map((name) => loadSegmentRanges(name)));

      const transcriptDataList = await Promise.all(
        transcriptNames.map(async (name) => {
          try { return await loadTranscriptFile(name); }
          catch (e) { console.warn("Missing transcript file:", name, e); return null; }
        })
      );

      let fallbackIndex = 0;

      transcriptDataList.forEach((td) => {
        if (!td || !td.transcriptFile || !Array.isArray(td.annotations)) return;

        const needIds = new Set(byTranscript.get(td.transcriptFile) || []);
        const anns = td.annotations.filter((ann) => needIds.has(ann.id));

        anns.forEach((ann) => {
          const itemKey = `${td.transcriptFile}__${ann.id}`;
          const saved = itemLayout[itemKey];

          const defaultX = CONFIG.defaultPX_X + fallbackIndex * CONFIG.cascadeStep;
          const defaultY = CONFIG.defaultPX_Y + fallbackIndex * CONFIG.cascadeStep;

          const xPX = toPXMaybe(saved?.x ?? ann.x, defaultX);
          const yPX = toPXMaybe(saved?.y ?? ann.y, defaultY);

          const card = createAnnotationCard(td.transcriptFile, ann, itemKey, saved);
          card.style.left = `${xPX}px`;
          card.style.top  = `${yPX}px`;

          if (typeof saved?.title === "string") card.querySelector(".card-title").textContent = saved.title;

          const bodyEl = card.querySelector(".card-body");
          if (bodyEl && typeof saved?.desc === "string") bodyEl.textContent = saved.desc;

          const quoteEl = card.querySelector(".card-quote");
          if (quoteEl && typeof saved?.quote === "string") quoteEl.textContent = saved.quote;

          const bodyWrap = card.querySelector('[data-wrap="body"]');
          const bodyCaret = card.querySelector('[data-caret="body"]');
          const quoteWrap = card.querySelector('[data-wrap="quote"]');
          const quoteCaret = card.querySelector('[data-caret="quote"]');

          if (bodyWrap && bodyEl && saved?.bodyCollapsed !== undefined) {
            setCollapsed(bodyWrap, bodyEl, bodyCaret, !!saved.bodyCollapsed);
          }
          if (quoteWrap && quoteEl && saved?.quoteCollapsed !== undefined) {
            setCollapsed(quoteWrap, quoteEl, quoteCaret, !!saved.quoteCollapsed);
          }

          els.board.appendChild(card);
          fallbackIndex++;
        });
      });

      Object.entries(textLayout).forEach(([tbKey, tb]) => {
        const el = createTextBlock(tbKey, tb?.text ?? "Type hereâ€¦", tb?.colorClass ?? "");
        el.style.left = `${toPXMaybe(tb?.x, 120)}px`;
        el.style.top  = `${toPXMaybe(tb?.y, 120)}px`;
        els.board.appendChild(el);
        });

      if (!els.board.querySelector(".card") && !els.board.querySelector(".text-block")) {
        els.board.innerHTML = `<div class="empty">No matching annotation cards could be loaded. (Maybe missing transcript json files.)</div>`;
      }

      requestAnimationFrame(() => {
        const currentLayout = loadLayoutFromLocal(activeCategory.label) || { items: {}, textBlocks: {} };
        const items = currentLayout.items || {};

        els.board.querySelectorAll(".card").forEach((card) => {
          const itemKey = card.dataset.key;
          const saved = items[itemKey] || {};

          const bodyWrap = card.querySelector('[data-wrap="body"]');
          const bodyEl = card.querySelector(".card-body");
          const bodyCaret = card.querySelector('[data-caret="body"]');

          const quoteWrap = card.querySelector('[data-wrap="quote"]');
          const quoteEl = card.querySelector(".card-quote");
          const quoteCaret = card.querySelector('[data-caret="quote"]');

          if (bodyWrap && bodyEl && saved.bodyCollapsed === undefined) {
            const shouldCollapse = isMoreThanOneLine(bodyEl);
            setCollapsed(bodyWrap, bodyEl, bodyCaret, shouldCollapse);
            upsertLocalItem(activeCategory.label, itemKey, { bodyCollapsed: shouldCollapse });
          }

          if (quoteWrap && quoteEl && saved.quoteCollapsed === undefined) {
            setCollapsed(quoteWrap, quoteEl, quoteCaret, true);
            upsertLocalItem(activeCategory.label, itemKey, { quoteCollapsed: true });
          }
        });
      });
    }

    function createAnnotationCard(transcriptFile, ann, itemKey, savedLayout) {
      const card = document.createElement("div");
      card.className = "card";
      card.dataset.key = itemKey;

      const ts = ann?.annotated_messages?.[0]?.timestamp || ann?.timestamp || "";
      const rawQuote = (ann?.annotated_messages?.[0]?.content ?? "");
      const rawDesc = (ann?.description ?? "");
      const hasDesc = String(rawDesc).trim().length > 0;
      const hasQuote = String(rawQuote).trim().length > 0;

      const actionsHtml = `
        <div class="card-actions">
          <button class="icon-btn" title="Delete" data-action="del">ðŸ—‘</button>
        </div>
      `;

      card.innerHTML = `
        <div class="card-header">
          <div class="card-title" contenteditable="true" spellcheck="false">${escapeHtml(ann?.label ?? "(no label)")}</div>
          ${actionsHtml}
        </div>

        ${hasDesc ? `
          <div class="toggle-wrap" data-wrap="body" data-collapsed="0" title="Click edge/blank to toggle â€¢ Use caret to expand/collapse">
            <button class="caret-mini" type="button" data-caret="body" aria-label="Toggle note">â–¼</button>
            <div class="card-body" contenteditable="true" spellcheck="false">${escapeHtml(rawDesc)}</div>
          </div>
        ` : ``}

        ${hasQuote ? `
          <div class="toggle-wrap" data-wrap="quote" data-collapsed="0" title="Click edge/blank to toggle â€¢ Use caret to expand/collapse">
            <button class="caret-mini" type="button" data-caret="quote" aria-label="Toggle quote">â–¼</button>
            <div class="card-quote" contenteditable="true" spellcheck="false">${escapeHtml(rawQuote)}</div>
          </div>
        ` : ``}

        <div class="card-meta">
          <div class="meta-left">${escapeHtml(transcriptFile)} â€¢ ${escapeHtml(ts)}</div>

          <div class="meta-right">
            <select class="tag-select" data-tag="tag1" title="Tag 1">
              <option value="-">-</option>
              <option value="M">M</option>
              <option value="C">C</option>
            </select>

            <select class="tag-select" data-tag="tag2" title="Tag 2">
              <option value="-">-</option>
              <option value="I">I</option>
              <option value="II">II</option>
              <option value="III">III</option>
              <option value="IV">IV</option>
            </select>
          </div>
        </div>
      `;

      // apply preset defaults BUT do not override saved layout
      const tag1Sel = card.querySelector('[data-tag="tag1"]');
      const tag2Sel = card.querySelector('[data-tag="tag2"]');

      const preset = getPresetFor(transcriptFile, ann);

      const savedTag1 = savedLayout?.tag1;
        const savedTag2 = savedLayout?.tag2;

        const hasSavedTag1 = (typeof savedTag1 === "string" && savedTag1 !== "-");
        const hasSavedTag2 = (typeof savedTag2 === "string" && savedTag2 !== "-");

        if (tag1Sel) tag1Sel.value = (hasSavedTag1 ? savedTag1 : (preset.tag1 || "-"));
        if (tag2Sel) tag2Sel.value = (hasSavedTag2 ? savedTag2 : (preset.tag2 || "-"));

        if (activeCategory && !hasSavedTag2 && preset.tag2 && preset.tag2 !== "-") {
        upsertLocalItem(activeCategory.label, itemKey, { tag2: preset.tag2 });
        }
        if (activeCategory && !hasSavedTag1 && preset.tag1 && preset.tag1 !== "-") {
        upsertLocalItem(activeCategory.label, itemKey, { tag1: preset.tag1 });
        }

      // Selection 
      card.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;

        const isEditing = e.target?.isContentEditable;
        const isButton = e.target?.closest("button");
        if (isButton) return;

        const key = card.dataset.key;

        if (isEditing) {
          if (e.shiftKey) toggleSelectionKey(key);
          return;
        }

        if (e.shiftKey) toggleSelectionKey(key);
        else if (!selection.keys.has(key)) setSingleSelection(key);

        if (selection.keys.size >= 2) startGroupDrag(e, card);
        else startSingleDrag(e, card);
      });

      // save edits
      const titleEl = card.querySelector(".card-title");
      const descEl = card.querySelector(".card-body");
      const quoteEl = card.querySelector(".card-quote");

      const saveEdits = () => {
        if (!activeCategory) return;
        upsertLocalItem(activeCategory.label, itemKey, {
          title: titleEl?.textContent ?? "",
          desc: descEl?.textContent ?? "",
          quote: quoteEl?.textContent ?? "",
          tag1: tag1Sel?.value ?? "-",
          tag2: tag2Sel?.value ?? "-",
        });
      };

      titleEl?.addEventListener("input", saveEdits);
      descEl?.addEventListener("input", saveEdits);
      quoteEl?.addEventListener("input", saveEdits);

      tag1Sel?.addEventListener("change", saveEdits);
      tag2Sel?.addEventListener("change", saveEdits);

      // toggle wiring
      const bodyWrap = card.querySelector('[data-wrap="body"]');
      const bodyCaret = card.querySelector('[data-caret="body"]');
      if (bodyWrap && descEl) wireToggle(bodyWrap, descEl, bodyCaret, itemKey, "bodyCollapsed");

      const quoteWrap = card.querySelector('[data-wrap="quote"]');
      const quoteCaret = card.querySelector('[data-caret="quote"]');
      if (quoteWrap && quoteEl) wireToggle(quoteWrap, quoteEl, quoteCaret, itemKey, "quoteCollapsed");

      // delete
      card.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-action]");
        if (!btn) return;
        if (btn.dataset.action === "del") {
          if (!activeCategory) return;
          removeLocalItem(activeCategory.label, itemKey);
          selection.keys.delete(itemKey);
          applySelectionUI();
          card.remove();
        }
      });

      return card;
    }

    function createTextBlock(tbKey, initialText, initialColorClass = "") {
  const block = document.createElement("div");
  block.className = "text-block";
  block.dataset.key = tbKey;

  block.innerHTML = `
  <div class="tb-header">
    <div style="font-weight:800;font-size:12px;color:#2c3e50;">Label</div>

    <!-- hover-only actions -->
    <div class="tb-actions">
      <div class="tb-colorbar" data-colorbar title="Text block color">
        <span class="tb-dot" data-color="" aria-label="Default"></span>
        <span class="tb-dot" data-color="tb-yellow" aria-label="Yellow"></span>
        <span class="tb-dot" data-color="tb-pink" aria-label="Pink"></span>
        <span class="tb-dot" data-color="tb-blue" aria-label="Blue"></span>
        <span class="tb-dot" data-color="tb-green" aria-label="Green"></span>
      </div>

      <button class="icon-btn" title="Delete" data-action="del">ðŸ—‘</button>
    </div>
  </div>

  <div class="text" contenteditable="true" spellcheck="false">${escapeHtml(initialText)}</div>
`;

  // apply initial color from local
  if (initialColorClass) applyTextBlockColor(block, initialColorClass);

  // mark active dot
  function syncDots() {
        const current =
        TB_COLOR_CLASSES.find(c => block.classList.contains(c)) || "";
        block.querySelectorAll(".tb-dot").forEach(dot => {
        dot.classList.toggle("active", dot.dataset.color === current);
        });
    }
    syncDots();

    // clicking dots: change color + save
    const colorbar = block.querySelector("[data-colorbar]");
    colorbar?.addEventListener("click", (e) => {
        const dot = e.target.closest(".tb-dot");
        if (!dot) return;
        if (!activeCategory) return;

        const cls = dot.dataset.color || ""; // "" means default
        applyTextBlockColor(block, cls);
        syncDots();
        upsertLocalItem(activeCategory.label, tbKey, { colorClass: cls });
    });

    // selection + drag (ä¿ç•™ä½ çš„é‚è¼¯ï¼Œä½†è¦æŽ’é™¤é»žè‰²é»žæ™‚è§¸ç™¼æ‹–æ›³)
    block.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;

        const isEditing = e.target?.isContentEditable;
        const isButton = e.target?.closest("button");
        const isOnActions = e.target?.closest(".tb-actions");
        if (isButton || isOnActions) return;

        const key = block.dataset.key;

        if (isEditing) {
        if (e.shiftKey) toggleSelectionKey(key);
        return;
        }

        if (e.shiftKey) toggleSelectionKey(key);
        else if (!selection.keys.has(key)) setSingleSelection(key);

        if (selection.keys.size >= 2) startGroupDrag(e, block);
        else startSingleDrag(e, block);
    });

    // save text edits
    const textEl = block.querySelector(".text");
    textEl.addEventListener("input", () => {
        if (!activeCategory) return;
        upsertLocalItem(activeCategory.label, tbKey, { text: textEl.textContent ?? "" });
    });

    // delete
    block.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-action]");
        if (!btn) return;
        if (btn.dataset.action === "del") {
        if (!activeCategory) return;
        removeLocalItem(activeCategory.label, tbKey);
        selection.keys.delete(tbKey);
        applySelectionUI();
        block.remove();
        }
    });

    return block;
    }
    function clearLocalLayout() {
      if (!activeCategory) return;
      localStorage.removeItem(lsKeyForCategory(activeCategory.label));
      clearSelection();
      renderBoardForActiveCategory();
    }

    function addTextBlock() {
      if (!activeCategory) { alert("Select a category first."); return; }
      const tbKey = `tb__${Date.now()}`;
      const block = createTextBlock(tbKey, "Type hereâ€¦");
      const x = els.boardWrap.scrollLeft + 120;
      const y = els.boardWrap.scrollTop + 120;
      block.style.left = `${x}px`;
      block.style.top  = `${y}px`;
      els.board.appendChild(block);
      upsertLocalItem(activeCategory.label, tbKey, { x, y, text: "Type hereâ€¦" });
    }

    function saveLayoutNow() {
      if (!activeCategory) { alert("Select a category first."); return; }

      const layout = loadLayoutFromLocal(activeCategory.label) || { items: {}, textBlocks: {} };
      layout.items = layout.items || {};
      layout.textBlocks = layout.textBlocks || {};

      els.board.querySelectorAll(".card").forEach((card) => {
        const key = card.dataset.key;
        const x = parseFloat(card.style.left || "0");
        const y = parseFloat(card.style.top || "0");
        const title = card.querySelector(".card-title")?.textContent ?? "";
        const desc = card.querySelector(".card-body")?.textContent ?? "";
        const quote = card.querySelector(".card-quote")?.textContent ?? "";

        const bodyWrap = card.querySelector('[data-wrap="body"]');
        const quoteWrap = card.querySelector('[data-wrap="quote"]');

        const tag1 = card.querySelector('[data-tag="tag1"]')?.value ?? "-";
        const tag2 = card.querySelector('[data-tag="tag2"]')?.value ?? "-";

        layout.items[key] = {
          ...(layout.items[key] || {}),
          x, y, title, desc, quote,
          tag1, tag2,
          bodyCollapsed: bodyWrap ? (bodyWrap.dataset.collapsed === "1") : undefined,
          quoteCollapsed: quoteWrap ? (quoteWrap.dataset.collapsed === "1") : undefined,
        };
      });

      els.board.querySelectorAll(".text-block").forEach((tb) => {
        const key = tb.dataset.key;
        const x = parseFloat(tb.style.left || "0");
        const y = parseFloat(tb.style.top || "0");
        const text = tb.querySelector(".text")?.textContent ?? "";
        layout.textBlocks[key] = { ...(layout.textBlocks[key] || {}), x, y, text };
      });

      saveLayoutToLocal(activeCategory.label, layout);

      const old = els.btnSaveLayout.textContent;
      els.btnSaveLayout.textContent = "Saved!";
      setTimeout(() => (els.btnSaveLayout.textContent = old), 900);
    }

    // ---- Marquee selection on empty board ----
    els.board.addEventListener("pointerdown", (e) => {
      if (e.button !== 0) return;

      const onItem = e.target.closest(".card, .text-block");
      const onEditable = e.target?.isContentEditable;
      const onButton = e.target?.closest("button");

      if (onButton || onEditable) return;
      if (onItem) return;

      startMarquee(e);
      els.board.setPointerCapture(e.pointerId);

      const move = (ev) => updateMarquee(ev);
      const up = (ev) => {
        try { els.board.releasePointerCapture(ev.pointerId); } catch {}
        els.board.removeEventListener("pointermove", move);
        els.board.removeEventListener("pointerup", up);
        els.board.removeEventListener("pointercancel", up);
        endMarquee();
      };

      els.board.addEventListener("pointermove", move);
      els.board.addEventListener("pointerup", up);
      els.board.addEventListener("pointercancel", up);
    });

    // click empty to clear selection
    els.board.addEventListener("click", (e) => {
      const onItem = e.target.closest(".card, .text-block");
      const onButton = e.target.closest("button");
      if (onButton) return;
      if (!onItem && !e.shiftKey) clearSelection();
    });

    // UI events
    els.btnAddText.addEventListener("click", addTextBlock);
    els.btnSaveLayout.addEventListener("click", saveLayoutNow);
    els.btnClearLocal.addEventListener("click", clearLocalLayout);

    (async function debugProbeAll(){
  const tf = "Aria";
  for (const k of [0,1,2,3,4]) {
    const url = `../server/segmented/${tf}/${k}.json`;
    const res = await fetch(url, { cache:"no-store" });
    console.log("[PROBE]", k, res.status, url);
  }
})();
    // boot
    (async function main() {
      try {
        await loadCategories();
        if (categories.length > 0) await selectCategory(categories[0].label);
      } catch (e) {
        console.error(e);
        els.categoryList.innerHTML = `<div class="empty">Failed to load categories. Check paths and server.</div>`;
      }
    })();
  </script>
</body>
</html>