<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcript Annotator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: monospace, sans-serif;
            height: 100vh;
            display: flex;
            background-color: #f5f5f5;
        }

        .container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        .sidebar {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            overflow-y: auto;
        }

        .left-sidebar {
            width: 250px;
            border-right: 2px solid #34495e;
            position: relative;
        }

        .right-sidebar {
            width: 300px;
            background-color: #ecf0f1;
            color: #2c3e50;
            border-left: 2px solid #bdc3c7;
        }

        .main-content {
            flex: 1;
            background-color: white;
            padding: 20px;
            overflow-y: auto;
            position: relative;
            z-index: 10;
        }

        /* Segment Navigation Popup */
        .segment-nav {
            position: absolute;
            right: 0;
            /* transform: translateX(-100%); */
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            background: white;
            border: 1px solid #e0e0e0;
            /* border-radius: 8px; */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .segment-nav-header {
            padding: 15px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            font-size: 14px;
        }

        .segment-nav-item {
            padding: 4px 8px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            align-items: center;
            transition: background 0.2s;
        }

        .segment-nav-item:hover {
            outline: 2px solid #ffffff;
        }

        .segment-nav-item.active {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }

        .segment-nav-title {
            font-size: 10px;
            color: black;
        }

        /* Segment Visual Bar */
        .messages-panel {
            flex: 1;
            padding-right: 15px;
            border-right: 2px solid #e0e0e0;
            position: relative;
        }

        .segment-visual-bar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            background: #e0e0e0;
            z-index: 50;
        }

        .segment-bar-section {
            position: absolute;
            width: 100%;
            transition: all 0.3s ease;
            /* cursor: pointer; */
        }

        .segment-bar-section:hover {
            width: 8px;
            left: -1px;
        }

        .segment-bar-section.active {
            width: 8px;
            left: -1px;
            /* box-shadow: 0 0 8px rgba(0,0,0,0.3); */
        }

        /* Continuous Messages Display */
        .messages-container {
            position: relative;
            margin-left: 15px;
        }

        .message-group {
            position: relative;
        }

        .message-group.collapsed {
            max-height: 60px;
            overflow: hidden;
            position: relative;
        }

        .message-group.collapsed::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, rgba(255,255,255,0.9));
            pointer-events: none;
        }

        .segment-divider {
            margin: 20px 0;
            border-top: 2px dashed #e0e0e0;
            position: relative;
        }

        .segment-title-marker {
            position: absolute;
            left: 0;
            top: -12px;
            background: white;
            padding: 0 10px;
            font-size: 12px;
            color: #666;
            font-weight: bold;
        }

        .sidebar h2 {
            margin-bottom: 20px;
            font-size: 18px;
            border-bottom: 2px solid #34495e;
            padding-bottom: 10px;
        }

        .transcript-list {
            list-style: none;
        }

        .transcript-item {
            padding: 12px;
            margin: 5px 0;
            background-color: #34495e;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        .transcript-item:hover {
            background-color: #4a5f7a;
        }

        .transcript-item.active {
            background-color: #3498db;
        }

        .transcript-content {
            display: flex;
            position: relative;
            /* height: 100%; */
        }

        .messages-panel {
            flex: 1;
            padding-right: 15px;
        }

        .annotations-panel {
            flex: 0 0 300px;
            padding-left: 15px;
            position: relative;
        }

        .message {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px dashed #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            transition: all 0.2s ease;
            user-select: none;
            white-space: pre-wrap;
            line-height: 1.6;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #2c3e50;
        }

        .message:hover {
            filter: brightness(0.9);
            transform: translateX(2px);
        }

        .message.selected {
            border: 2px solid #3498db;
            box-shadow: 0 2px 5px rgba(52, 152, 219, 0.3);
        }

        .message.selecting {
            border: 2px solid #85c1e9;
        }

        .message.annotation-highlight {
            /* background-color: #e8f4fd !important; */
            border-left: 3px solid #3498db;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }

        .message:last-child {
            border-bottom: none;
        }

        .message.speaker-0 {
            background-color: #f9f9f9;
        }

        .message.speaker-1 {
            background-color: #ffffff;
        }

        .message.speaker-2 {
            background-color: #f0f0f0;
        }

        .message.speaker-3 {
            background-color: #e8e8e8;
        }

        .message.speaker-4 {
            background-color: #f5f5f5;
        }

        .message.hidden {
            display: none;
        }

        .speaker-filter {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .speaker-filter h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }

        .filter-checkbox {
            display: inline-flex;
            align-items: center;
            margin-right: 15px;
            margin-bottom: 5px;
        }

        .filter-checkbox input {
            margin-right: 5px;
        }

        .filter-checkbox label {
            font-size: 12px;
            cursor: pointer;
            margin-right: 8px;
        }

        .speaker-control {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
            /* background-color: white; */
        }

        .color-picker {
            width: 30px;
            height: 20px;
            border: 1px solid #ccc;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 8px;
        }

        .message-header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .speaker {
            margin-right: 10px;
        }

        .message-content {
            white-space: pre-wrap;
        }

        .annotation-panel {
            padding-right: 0px;
        }

        .annotation-panel h2 {
            color: #2c3e50;
            border-bottom: 2px solid #bdc3c7;
        }

        .annotation-form {
            margin-top: 20px;
        }

        .selection-annotation {
            background-color: #e8f4fd;
            border: 1px solid #3498db;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 15px;
            display: none;
            position: absolute;
            width: 280px;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
            right: 0;
        }

        .selection-info {
            font-size: 12px;
            color: #2980b9;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .annotation-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-primary {
            background-color: #3498db;
            color: white;
        }

        .btn-secondary {
            background-color: #95a5a6;
            color: white;
        }

        .btn:hover {
            opacity: 0.9;
        }

        .saved-annotations {
            /* max-height: 70vh; */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding-right: 12px;
        }
        .annotation-display {
            /* background-color: #fff3cd;
            border: 1px solid #ffc107; */
            background-color: rgba(179, 224, 255, 0.4);
            border: 1px solid #3498db;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        /* Positioned annotations in the main annotations panel */
        .annotations-panel .annotation-display {
            position: absolute;
            right: 0;
            width: 280px;
        }

        /* Sidebar annotations (no absolute positioning) */
        .saved-annotations .annotation-display {
            position: static;
            width: auto;
            margin-bottom: 15px;
        }

        .annotation-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0;
        }

        .annotation-delete-btn {
            background: transparent;
            color: #dc3545;
            border: none;
            border-radius: 3px;
            width: 24px;
            height: 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin-left: 8px;
            flex-shrink: 0;
        }

        .annotation-delete-btn:hover {
            background: #eeeeee;
        }

        .annotation-label {
            font-weight: bold;
            color: #043a85;
            font-size: 14px;
            margin-bottom: 0;
            flex: 1;
        }

        .annotation-description {
            color: #043a85;
            font-size: 12px;
            line-height: 1.4;
        }

        .annotation-meta {
            font-size: 10px;
            color: #6c757d;
            margin-top: 5px;
            font-style: italic;
        }


        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-group textarea {
            height: 100px;
            resize: vertical;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #7f8c8d;
        }

        .error {
            color: #e74c3c;
            background-color: #fadbd8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Left Sidebar - Transcript List -->
        <div class="sidebar left-sidebar">
            <h2>Transcripts</h2>
            <ul class="transcript-list" id="transcriptList">
                <li class="loading">Loading transcripts...</li>
            </ul>
                <!-- Segment Navigation Popup -->
            <div class="segment-nav" id="segmentNav" style="display: none;">
                <!-- <div class="segment-nav-header">
                    Segments
                </div> -->
                <div id="segmentNavItems"></div>
            </div>
        </div>

        <!-- Main Content - Transcript Display -->
        <div class="main-content">
            <div class="speaker-filter" id="speakerFilter" style="display: none;">
                <h3>Filter by Speaker:</h3>
                <div id="filterCheckboxes"></div>
            </div>
            
            <!-- <div class="segment-controls" id="segmentControls" style="display: none;">
                <h3>Segment Controls:</h3>
                <button id="expandAllSegments">Expand All</button>
                <button id="collapseAllSegments">Collapse All</button>
            </div> -->
            
            <div class="transcript-content" id="transcriptContent">
                
                <!-- Segment Visual Bar -->
                <div class="segment-visual-bar" id="segmentVisualBar"></div>
                
                <div class="messages-panel" id="messagesPanel">
                    <div class="messages-container" id="messagesContainer">
                        <p class="loading">Select a transcript from the sidebar to view its contents.</p>
                    </div>
                </div>
                <div class="annotations-panel" id="annotationsPanel">
                    <!-- Selection Annotation Form -->
                    <div class="selection-annotation" id="selectionAnnotation">
                        <div class="selection-info" id="selectionInfo"></div>
                        <div class="form-group">
                            <label for="selectionLabel">Label:</label>
                            <input type="text" id="selectionLabel" placeholder="">
                        </div>
                        <div class="form-group">
                            <label for="selectionDescription">Description:</label>
                            <textarea id="selectionDescription" placeholder=""></textarea>
                        </div>
                        <div class="annotation-actions">
                            <button class="btn btn-primary" id="saveAnnotation">Save Annotation</button>
                            <button class="btn btn-secondary" id="cancelAnnotation">Cancel</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Sidebar - Annotation Panel -->
        <div class="sidebar right-sidebar">
            <div class="annotation-panel">
                <h2>Saved Annotations</h2>
                <div id="savedAnnotations" class="saved-annotations">
                    <p class="loading">No annotations yet. Select messages in the transcript to create annotations.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TranscriptAnnotator {
            constructor() {
                this.transcripts = [];
                this.currentTranscript = null;
                this.speakers = [];
                this.speakerColorMap = new Map();
                this.speakerCustomColors = new Map();
                this.defaultColors = ['#f9f9f9', '#ffffff', '#f0f0f0', '#e8e8e8', '#f5f5f5'];
                this.isSelecting = false;
                this.selectionStart = null;
                this.selectedMessages = [];
                this.annotations = [];
                this.apiBaseUrl = 'http://localhost:8000/api';
                
                // Auto-scroll properties
                this.autoScrollInterval = null;
                this.autoScrollSpeed = 3; // pixels per interval
                this.autoScrollThreshold = 50; // pixels from edge to start auto-scroll
                
                this.init();
            }

            async init() {
                await this.loadTranscripts();
                this.bindEvents();
            }

            async loadTranscripts() {
                console.log('Loading transcripts from server...');
                try {
                    const transcriptList = document.getElementById('transcriptList');
                    transcriptList.innerHTML = '<li class="loading">Loading transcripts...</li>';

                    const response = await fetch(`${this.apiBaseUrl}/transcripts`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const transcriptFiles = data.transcripts;
                    
                    transcriptList.innerHTML = '';
                    this.transcripts = [];

                    for (const transcriptInfo of transcriptFiles) {
                        try {
                            // Load segmented transcript content
                            const contentResponse = await fetch(`${this.apiBaseUrl}/transcripts/${transcriptInfo.filename}/segmented`);
                            if (contentResponse.ok) {
                                const segments = await contentResponse.json();
                                this.transcripts.push({
                                    filename: transcriptInfo.filename,
                                    segments: segments
                                });

                                const listItem = document.createElement('li');
                                listItem.className = 'transcript-item';
                                listItem.textContent = transcriptInfo.filename.replace('.txt', '');
                                listItem.dataset.filename = transcriptInfo.filename;
                                transcriptList.appendChild(listItem);
                            }
                        } catch (error) {
                            console.warn(`Could not load ${transcriptInfo.filename}:`, error);
                        }
                    }

                    if (this.transcripts.length === 0) {
                        transcriptList.innerHTML = '<li class="error">No transcripts found</li>';
                    }
                } catch (error) {
                    console.error('Error loading transcripts:', error);
                    document.getElementById('transcriptList').innerHTML = '<li class="error">Error loading transcripts. Make sure the server is running.</li>';
                }
            }

            bindEvents() {
                const transcriptList = document.getElementById('transcriptList');
                transcriptList.addEventListener('click', async (event) => {
                    if (event.target.classList.contains('transcript-item')) {
                        await this.selectTranscript(event.target.dataset.filename);
                        
                        // Update active state
                        document.querySelectorAll('.transcript-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        event.target.classList.add('active');
                    }
                });

                // Add event listener for speaker filter checkboxes
                document.addEventListener('change', (event) => {
                    if (event.target.matches('#filterCheckboxes input[type="checkbox"]')) {
                        this.filterMessages();
                    }
                });

                // Add event listener for color picker changes
                document.addEventListener('input', (event) => {
                    if (event.target.matches('.color-picker')) {
                        const speaker = event.target.dataset.speaker;
                        const color = event.target.value;
                        this.updateSpeakerColor(speaker, color);
                    }
                });

                // Add message selection event listeners
                document.addEventListener('mousedown', (event) => {
                    if (event.target.closest('.message')) {
                        this.startMessageSelection(event);
                    }
                });

                document.addEventListener('mousemove', (event) => {
                    if (this.isSelecting) {
                        this.updateMessageSelection(event);
                    }
                });

                document.addEventListener('mouseup', (event) => {
                    if (this.isSelecting) {
                        this.endMessageSelection(event);
                    }
                });

                // Annotation form event listeners
                document.getElementById('saveAnnotation').addEventListener('click', async () => {
                    await this.saveSelection();
                });

                document.getElementById('cancelAnnotation').addEventListener('click', () => {
                    this.cancelSelection();
                });

                // Segment control event listeners
                // document.getElementById('expandAllSegments').addEventListener('click', () => {
                //     this.expandAllSegments();
                // });

                // document.getElementById('collapseAllSegments').addEventListener('click', () => {
                //     this.collapseAllSegments();
                // });

                // Delete annotation event listener
                document.addEventListener('click', async (event) => {
                    // Handle clicks on delete button or its SVG children
                    const deleteBtn = event.target.closest('.annotation-delete-btn');
                    if (deleteBtn) {
                        const annotationId = parseInt(deleteBtn.dataset.annotationId);
                        await this.deleteAnnotation(annotationId);
                        // if (confirm('Are you sure you want to delete this annotation?')) {
                        //     await this.deleteAnnotation(annotationId);
                        // }
                    }
                });

                // Reposition annotations on scroll
                document.getElementById('messagesPanel').addEventListener('scroll', () => {
                    this.positionAnnotations();
                    // Also reposition the annotation form if it's visible
                    const form = document.getElementById('selectionAnnotation');
                    if (form.style.display !== 'none') {
                        this.positionAnnotationForm();
                    }
                });

                // Reposition annotations on window resize
                window.addEventListener('resize', () => {
                    this.positionAnnotations();
                    // Also reposition the annotation form if it's visible
                    const form = document.getElementById('selectionAnnotation');
                    if (form.style.display !== 'none') {
                        this.positionAnnotationForm();
                    }
                });
            }

            async selectTranscript(filename) {
                const transcript = this.transcripts.find(t => t.filename === filename);
                if (transcript) {
                    // Clear existing annotations when switching transcripts
                    this.annotations = [];
                    this.clearSelection();
                    
                    this.currentTranscript = transcript;
                    await this.displayTranscript(transcript.segments);
                }
            }

            async displayTranscript(segments) {
                const transcriptContent = document.getElementById('transcriptContent');
                
                if (segments.length === 0) {
                    transcriptContent.innerHTML = '<p class="loading">No segments found in transcript.</p>';
                    return;
                }

                // Flatten all messages from all segments to extract speakers
                const allMessages = segments.flatMap(segment => segment.messages);
                
                // Extract unique speakers and assign colors
                this.speakers = [...new Set(allMessages.map(m => m.speaker))];
                this.speakerColorMap.clear();
                this.speakers.forEach((speaker, index) => {
                    this.speakerColorMap.set(speaker, index % 5);
                });

                // Create filter checkboxes
                this.createSpeakerFilter();

                // Show segment controls
                // document.getElementById('segmentControls').style.display = 'block';

                // Generate HTML with segments and inline annotations
                this.renderTranscriptWithAnnotations(segments);
                
                // Load annotations for this transcript
                await this.loadAnnotationsFromFile();
            }

            renderTranscriptWithAnnotations(segments) {
                const messagesContainer = document.getElementById('messagesContainer');
                const segmentNav = document.getElementById('segmentNav');
                const segmentNavItems = document.getElementById('segmentNavItems');
                const segmentVisualBar = document.getElementById('segmentVisualBar');
                const annotationsPanel = document.getElementById('annotationsPanel');
                
                // Clear containers
                messagesContainer.innerHTML = '';
                segmentNavItems.innerHTML = '';
                segmentVisualBar.innerHTML = '';
                
                // Clear only the annotation displays, not the form
                const existingAnnotations = annotationsPanel.querySelectorAll('.annotation-display');
                existingAnnotations.forEach(annotation => annotation.remove());
                
                // Show navigation
                segmentNav.style.display = 'block';
                
                // Generate segment colors
                this.segmentColors = this.generateSegmentColors(segments.length);
                this.segments = segments; // Store for later use
                this.segmentStates = segments.map(() => ({ expanded: true })); // All expanded by default
                
                // Render continuous messages with segment markers
                let globalMessageIndex = 0;
                let totalHeight = 0;
                const segmentPositions = [];
                
                segments.forEach((segment, segmentIndex) => {
                    const segmentColor = this.segmentColors[segmentIndex];
                    
                    // Add segment divider (except for first segment)
                    if (segmentIndex > 0) {
                        const divider = document.createElement('div');
                        divider.className = 'segment-divider';
                        divider.innerHTML = `<div class="segment-title-marker" style="color: ${segmentColor}">${this.escapeHtml(segment.title)}</div>`;
                        messagesContainer.appendChild(divider);
                    }
                    
                    // Create message group for this segment
                    const messageGroup = document.createElement('div');
                    messageGroup.className = 'message-group';
                    messageGroup.dataset.segmentIndex = segmentIndex;
                    
                    const startHeight = totalHeight;
                    
                    // Render messages
                    segment.messages.forEach((message) => {
                        const messageContent = message.content || '';
                        const displayContent = messageContent.trim() || '(No content)';
                        const colorClass = `speaker-${this.speakerColorMap.get(message.speaker)}`;
                        
                        const messageElement = document.createElement('div');
                        messageElement.className = `message ${colorClass}`;
                        messageElement.dataset.speaker = this.escapeHtml(message.speaker);
                        messageElement.dataset.messageIndex = globalMessageIndex;
                        messageElement.dataset.segmentIndex = segmentIndex;
                        messageElement.innerHTML = `<div class="message-header"><span class="speaker">[${this.escapeHtml(message.speaker)}]</span><span class="timestamp">${message.timestamp}</span></div><div class="message-content">${this.escapeHtml(displayContent)}</div>`;
                        
                        messageGroup.appendChild(messageElement);
                        globalMessageIndex++;
                    });
                    
                    messagesContainer.appendChild(messageGroup);
                    
                    // Calculate segment height (approximate)
                    const segmentHeight = segment.messages.length * 80; // Approximate message height
                    segmentPositions.push({
                        start: startHeight,
                        end: startHeight + segmentHeight,
                        color: segmentColor
                    });
                    totalHeight += segmentHeight;
                    
                    // Create navigation item
                    const navItem = document.createElement('div');
                    navItem.className = 'segment-nav-item';
                    navItem.dataset.segmentIndex = segmentIndex;
                    navItem.innerHTML = `
                        <div class="segment-nav-title" >${this.escapeHtml(segment.title)}</div>
                    `;
                    navItem.style.backgroundColor = segmentColor;
                    
                    navItem.addEventListener('click', () => this.scrollToSegment(segmentIndex));
                    segmentNavItems.appendChild(navItem);
                });
                
                // Set up scroll listener for highlighting current segment
                const mainContent = document.querySelector('.main-content');
                mainContent.addEventListener('scroll', () => this.updateActiveSegment());
                
                // Create visual bar segments after DOM is rendered
                setTimeout(() => {
                    this.updateVisualBar();
                    this.positionAnnotations();
                }, 100);
            }

            updateVisualBar() {
                const segmentVisualBar = document.getElementById('segmentVisualBar');
                const messagesPanel = document.getElementById('messagesPanel');
                
                if (!segmentVisualBar || !messagesPanel) return;
                
                segmentVisualBar.innerHTML = '';
                
                // Calculate total content height
                const totalHeight = messagesPanel.scrollHeight;
                
                this.segments.forEach((segment, index) => {
                    const messageGroup = document.querySelector(`.message-group[data-segment-index="${index}"]`);
                    if (messageGroup) {
                        const rect = messageGroup.getBoundingClientRect();
                        const panelRect = messagesPanel.getBoundingClientRect();
                        const offsetTop = messageGroup.offsetTop;
                        const height = messageGroup.offsetHeight;
                        
                        const barSection = document.createElement('div');
                        barSection.className = 'segment-bar-section';
                        barSection.style.backgroundColor = this.segmentColors[index];
                        barSection.style.position = 'absolute';
                        barSection.style.top = `${(offsetTop / totalHeight) * 100}%`;
                        barSection.style.height = `${(height / totalHeight) * 100}%`;
                        barSection.dataset.segmentIndex = index;
                        
                        // barSection.addEventListener('click', () => this.toggleSegment(index));
                        segmentVisualBar.appendChild(barSection);
                    }
                });
            }
            

            generateSegmentColors(count) {
                const colors = [
                    '#F3AEA6',  '#CAE6C1', '#D6C5DE', '#FAD4A2', '#F8D7E8',
                    '#FFFECB', '#E0D2B8', '#F0F0F0', '#ADC6DD',
                ];
                return Array.from({length: count}, (_, i) => colors[i % colors.length]);
            }

            scrollToSegment(segmentIndex) {
                const messageGroup = document.querySelector(`.message-group[data-segment-index="${segmentIndex}"]`);
                const messagesPanel = document.querySelector('.main-content');
    
                if (messageGroup && messagesPanel) {
                    const offset = 10; // Desired vertical offset in pixels
                    const targetPosition = messageGroup.offsetTop - offset;
                    
                    messagesPanel.scrollTo({
                        top: Math.max(0, targetPosition),
                        behavior: 'smooth'
                    });
                }
                // if (messageGroup) {
                //     messageGroup.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // }
            }

            toggleSegment(segmentIndex) {
                const messageGroup = document.querySelector(`.message-group[data-segment-index="${segmentIndex}"]`);
                if (messageGroup) {
                    this.segmentStates[segmentIndex].expanded = !this.segmentStates[segmentIndex].expanded;
                    
                    if (this.segmentStates[segmentIndex].expanded) {
                        messageGroup.classList.remove('collapsed');
                    } else {
                        messageGroup.classList.add('collapsed');
                    }
                }
            }

            updateActiveSegment() {
                // const messagesPanel = document.getElementById('messagesPanel');
                const mainContent = document.querySelector('.main-content');
                const scrollTop = messagesPanel.scrollTop;
                const panelHeight = messagesPanel.clientHeight;
                const scrollCenter = scrollTop + panelHeight / 2;
                
                // Find which segment has the most visible area
                let activeSegmentIndex = 0;
                let maxVisibleArea = 0;
                
                this.segments?.forEach((segment, index) => {
                    const messageGroup = document.querySelector(`.message-group[data-segment-index="${index}"]`);
                    if (messageGroup) {
                        // Calculate positions relative to the scroll container
                        const groupTop = messageGroup.offsetTop;
                        const groupBottom = groupTop + messageGroup.offsetHeight;
                        
                        // Calculate the currently visible viewport area within the scroll container
                        const viewportTop = mainContent.scrollTop;
                        const viewportBottom = mainContent.scrollTop + mainContent.clientHeight;
                        
                        console.log(`Segment ${index}: groupTop=${groupTop}, groupBottom=${groupBottom}, viewportTop=${viewportTop}, viewportBottom=${viewportBottom}`);
                        
                        // Only calculate visible area if the group intersects with the visible viewport
                        let visibleArea = 0;
                        if (groupBottom > viewportTop && groupTop < viewportBottom) {
                            const visibleTop = Math.max(groupTop, viewportTop);
                            const visibleBottom = Math.min(groupBottom, viewportBottom);
                            visibleArea = visibleBottom - visibleTop;
                        }
                        
                        console.log(`Segment ${index}: visible area = ${visibleArea}, maxVisibleArea = ${maxVisibleArea}`);
                        if (visibleArea > maxVisibleArea) {
                            maxVisibleArea = visibleArea;
                            activeSegmentIndex = index;
                        }
                    }
                });
                
                console.log('Active segment index:', activeSegmentIndex);
                // Update active states
                document.querySelectorAll('.segment-nav-item').forEach((item, index) => {
                    item.classList.toggle('active', index === activeSegmentIndex);
                });
                
                document.querySelectorAll('.segment-bar-section').forEach((section, index) => {
                    section.classList.toggle('active', index === activeSegmentIndex);
                });
            }

            positionAnnotations() {
                const annotationsPanel = document.getElementById('annotationsPanel');
                
                // Remove existing annotation displays, but keep the form
                const existingAnnotations = annotationsPanel.querySelectorAll('.annotation-display');
                existingAnnotations.forEach(annotation => annotation.remove());

                this.annotations.forEach(annotation => {
                    const startIndex = Math.min(...annotation.messageIndices);
                    const endIndex = Math.max(...annotation.messageIndices);
                    
                    const startMessage = document.querySelector(`[data-message-index="${startIndex}"]`);
                    const endMessage = document.querySelector(`[data-message-index="${endIndex}"]`);
                    
                    if (startMessage && endMessage) {
                        const startRect = startMessage.getBoundingClientRect();
                        const endRect = endMessage.getBoundingClientRect();
                        const panelRect = annotationsPanel.getBoundingClientRect();
                        
                        const annotationElement = document.createElement('div');
                        annotationElement.className = 'annotation-display';
                        annotationElement.style.top = `${startRect.top - panelRect.top}px`;
                        annotationElement.style.height = `${endRect.bottom - startRect.top}px`;
                        
                        // Add data attribute for message indices
                        annotationElement.dataset.messageIndices = JSON.stringify(annotation.messageIndices);
                        
                        // Add hover event listeners
                        annotationElement.addEventListener('mouseenter', () => {
                            this.highlightAnnotationMessages(annotation.messageIndices);
                        });
                        
                        annotationElement.addEventListener('mouseleave', () => {
                            this.clearAnnotationHighlight();
                        });
                        
                        const startMsg = startIndex + 1;
                        const endMsg = endIndex + 1;
                        const messageRange = startMsg === endMsg ? `Message ${startMsg}` : `Messages ${startMsg}-${endMsg}`;
                        
                        annotationElement.innerHTML = this.minifyHtml(`
                            <div class="annotation-header">
                                <div class="annotation-label">${this.escapeHtml(annotation.label)}</div>
                                <button class="annotation-delete-btn" data-annotation-id="${annotation.id}" title="Delete annotation">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M10 11v6"/><path d="M14 11v6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                    </svg>
                                </button>
                            </div>
                            ${annotation.description ? `<div class="annotation-description">${this.escapeHtml(annotation.description)}</div>` : ''}
                            <div class="annotation-meta">
                                <div class="annotation-messages">${messageRange}</div>
                                <div class="annotation-timestamp">${new Date(annotation.timestamp).toLocaleString()}</div>
                            </div>
                        `);
                        
                        annotationsPanel.appendChild(annotationElement);
                    }
                });
            }

            createInlineAnnotationHTML(annotation) {
                console.log('Creating inline annotation HTML for:', annotation);
                const startMsg = Math.min(...annotation.messageIndices) + 1;
                const endMsg = Math.max(...annotation.messageIndices) + 1;
                const messageRange = startMsg === endMsg ? `Message ${startMsg}` : `Messages ${startMsg}-${endMsg}`;
                
                return this.minifyHtml(`
                    <div class="annotation-display">
                        <div class="annotation-label">${this.escapeHtml(annotation.label)}</div>
                        ${annotation.description ? `<div class="annotation-description">${this.escapeHtml(annotation.description)}</div>` : ''}
                        <div class="annotation-meta">
                            <div class="annotation-messages">${messageRange}</div>
                            <div class="annotation-timestamp">${new Date(annotation.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
                `);
            }

            async updateAnnotationsSidebar() {
                const savedAnnotations = document.getElementById('savedAnnotations');
                
                if (!this.currentTranscript) {
                    savedAnnotations.innerHTML = '<p class="loading">No transcript selected.</p>';
                    return;
                }

                // Show loading state
                savedAnnotations.innerHTML = '<p class="loading">Loading annotations...</p>';
                
                try {
                    // Fetch latest annotations from server
                    const response = await fetch(`${this.apiBaseUrl}/annotations/${this.currentTranscript.filename}`);
                    let annotations = [];
                    
                    if (response.ok) {
                        const data = await response.json();
                        annotations = data.annotations || [];
                        // Update local cache with server data
                        this.annotations = annotations;
                    } else if (response.status === 404) {
                        annotations = [];
                        this.annotations = [];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    // Display annotations
                    if (annotations.length === 0) {
                        savedAnnotations.innerHTML = '<p class="loading">No annotations yet. Select messages in the transcript to create annotations.</p>';
                        return;
                    }

                    let html = '';
                    annotations.forEach((annotation, index) => {
                        const startMsg = Math.min(...annotation.messageIndices) + 1;
                        const endMsg = Math.max(...annotation.messageIndices) + 1;
                        const messageRange = startMsg === endMsg ? `Message ${startMsg}` : `Messages ${startMsg}-${endMsg}`;
                        
                        html += this.minifyHtml(`
                            <div class="annotation-display">
                                <div class="annotation-header">
                                    <div class="annotation-label">${this.escapeHtml(annotation.label)}</div>
                                    <button class="annotation-delete-btn" data-annotation-id="${annotation.id}" title="Delete annotation">
                                        <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                            <path d="M10 11v6"/><path d="M14 11v6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M3 6h18"/><path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
                                        </svg>
                                    </button>
                                </div>
                                ${annotation.description ? `<div class="annotation-description">${this.escapeHtml(annotation.description)}</div>` : ''}
                                <div class="annotation-meta">
                                    <div class="annotation-messages">${messageRange}</div>
                                    <div class="annotation-timestamp">${new Date(annotation.timestamp).toLocaleString()}</div>
                                </div>
                            </div>
                        `);
                    });

                    savedAnnotations.innerHTML = html;
                    
                } catch (error) {
                    console.error('Error loading annotations for sidebar:', error);
                    savedAnnotations.innerHTML = '<p class="error">Error loading annotations. Please check the server connection.</p>';
                }
            }

            createSpeakerFilter() {
                const speakerFilter = document.getElementById('speakerFilter');
                const filterCheckboxes = document.getElementById('filterCheckboxes');
                
                speakerFilter.style.display = 'block';
                
                let checkboxHtml = '';
                this.speakers.forEach((speaker, index) => {
                    const defaultColor = this.defaultColors[index % this.defaultColors.length];
                    const currentColor = this.speakerCustomColors.get(speaker) || defaultColor;
                    
                    checkboxHtml += `<div class="speaker-control"><div class="filter-checkbox"><input type="checkbox" id="speaker-${this.escapeHtml(speaker)}" checked data-speaker="${this.escapeHtml(speaker)}"><label for="speaker-${this.escapeHtml(speaker)}">${this.escapeHtml(speaker)}</label></div><input type="color" class="color-picker" value="${currentColor}" data-speaker="${this.escapeHtml(speaker)}" title="Change color for ${this.escapeHtml(speaker)}"></div>`;
                });
                
                filterCheckboxes.innerHTML = checkboxHtml;
                
                // Apply current colors to messages
                this.applyCustomColors();
            }

            applyCustomColors() {
                const messages = document.querySelectorAll('.message');
                messages.forEach(message => {
                    const speaker = message.dataset.speaker;
                    const customColor = this.speakerCustomColors.get(speaker);
                    if (customColor) {
                        message.style.backgroundColor = customColor;
                    } else {
                        // Use default color
                        const colorIndex = this.speakerColorMap.get(speaker);
                        const defaultColor = this.defaultColors[colorIndex % this.defaultColors.length];
                        message.style.backgroundColor = defaultColor;
                    }
                });
            }

            updateSpeakerColor(speaker, color) {
                this.speakerCustomColors.set(speaker, color);
                
                // Update all messages for this speaker
                const speakerMessages = document.querySelectorAll(`.message[data-speaker="${speaker}"]`);
                speakerMessages.forEach(message => {
                    message.style.backgroundColor = color;
                });
            }

            startMessageSelection(event) {
                event.preventDefault();
                const message = event.target.closest('.message');
                if (!message) return;

                this.clearSelection();
                this.isSelecting = true;
                this.selectionStart = parseInt(message.dataset.messageIndex);
                this.selectedMessages = [this.selectionStart];
                this.updateSelectionDisplay();
            }

            updateMessageSelection(event) {
                if (!this.isSelecting) return;

                const message = event.target.closest('.message');
                if (!message) return;

                const currentIndex = parseInt(message.dataset.messageIndex);
                const startIndex = this.selectionStart;
                
                // Handle auto-scrolling based on cursor position
                this.handleAutoScroll(event);
                
                // Clear previous selection display
                this.clearSelectionDisplay();
                
                // Determine selection range
                const minIndex = Math.min(startIndex, currentIndex);
                const maxIndex = Math.max(startIndex, currentIndex);
                
                this.selectedMessages = [];
                for (let i = minIndex; i <= maxIndex; i++) {
                    this.selectedMessages.push(i);
                }
                
                this.updateSelectionDisplay();
            }

            endMessageSelection(event) {
                if (!this.isSelecting) return;
                
                this.isSelecting = false;
                
                // Stop auto-scrolling
                this.stopAutoScroll();
                
                if (this.selectedMessages.length > 0) {
                    this.showAnnotationForm();
                } else {
                    this.clearSelection();
                }
            }

            clearSelectionDisplay() {
                document.querySelectorAll('.message').forEach(msg => {
                    msg.classList.remove('selected', 'selecting');
                });
            }

            updateSelectionDisplay() {
                this.clearSelectionDisplay();
                this.selectedMessages.forEach(index => {
                    const message = document.querySelector(`[data-message-index="${index}"]`);
                    if (message) {
                        if (this.isSelecting) {
                            message.classList.add('selecting');
                        } else {
                            message.classList.add('selected');
                        }
                    }
                });
            }

            showAnnotationForm() {
                const form = document.getElementById('selectionAnnotation');
                const info = document.getElementById('selectionInfo');
                
                if (!form) {
                    console.error('Annotation form not found');
                    return;
                }
                
                const messageCount = this.selectedMessages.length;
                const startMsg = this.selectedMessages[0] + 1;
                const endMsg = this.selectedMessages[this.selectedMessages.length - 1] + 1;
                
                if (messageCount === 1) {
                    info.textContent = `Selected message ${startMsg}`;
                } else {
                    info.textContent = `Selected messages ${startMsg}-${endMsg} (${messageCount} messages)`;
                }
                
                // Show form first, then position it
                form.style.display = 'block';
                
                // Position the form next to the selected messages
                setTimeout(() => {
                    this.positionAnnotationForm();
                }, 0);
                
                // document.getElementById('selectionLabel').focus();
            }

            positionAnnotationForm() {
                const form = document.getElementById('selectionAnnotation');
                const annotationsPanel = document.getElementById('annotationsPanel');
                
                if (!form || this.selectedMessages.length === 0) return;
                
                const startIndex = Math.min(...this.selectedMessages);
                const startMessage = document.querySelector(`[data-message-index="${startIndex}"]`);
                
                if (startMessage && annotationsPanel) {
                    try {
                        const startRect = startMessage.getBoundingClientRect();
                        const panelRect = annotationsPanel.getBoundingClientRect();
                        
                        // Position form at the same height as the first selected message
                        const topPosition = Math.max(0, startRect.top - panelRect.top);
                        form.style.top = `${topPosition}px`;
                        
                        console.log('Positioning form at top:', topPosition);
                    } catch (error) {
                        console.error('Error positioning form:', error);
                        // Fallback to top of panel
                        form.style.top = '10px';
                    }
                } else {
                    // Fallback positioning if elements not found
                    form.style.top = '10px';
                    console.log('Using fallback positioning');
                }
            }

            async saveSelection() {
                const label = document.getElementById('selectionLabel').value.trim();
                const description = document.getElementById('selectionDescription').value.trim();
                
                if (!label) {
                    alert('Please enter a label for the annotation.');
                    return;
                }
                
                const annotation = {
                    id: Date.now(),
                    label: label,
                    description: description,
                    messageIndices: [...this.selectedMessages],
                    timestamp: new Date().toISOString()
                };
                
                this.annotations.push(annotation);
                console.log('Annotation saved:', annotation);
                
                // Save annotations to server
                await this.saveAnnotationsToFile();
                
                // Refresh displays
                this.positionAnnotations();
                await this.updateAnnotationsSidebar();
                
                this.clearSelection();
            }

            async saveAnnotationsToFile() {
                if (!this.currentTranscript) return;
                
                try {
                    const annotationsData = {
                        transcriptFile: this.currentTranscript.filename,
                        annotations: this.annotations,
                        lastModified: new Date().toISOString()
                    };
                    
                    const response = await fetch(`${this.apiBaseUrl}/annotations/${this.currentTranscript.filename}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(annotationsData)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log('Annotations saved successfully:', result);
                    
                } catch (error) {
                    console.error('Error saving annotations:', error);
                    alert('Error saving annotations. Please check the server connection.');
                }
            }

            async loadAnnotationsFromFile() {
                if (!this.currentTranscript) return;
                
                try {
                    const response = await fetch(`${this.apiBaseUrl}/annotations/${this.currentTranscript.filename}`);
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.annotations && Array.isArray(data.annotations)) {
                            this.annotations = data.annotations;
                            console.log('Loaded annotations from server:', this.annotations);
                            
                            // Refresh displays
                            this.positionAnnotations();
                            await this.updateAnnotationsSidebar();
                        }
                    } else if (response.status === 404) {
                        console.log('No annotation file found for', this.currentTranscript.filename);
                        this.annotations = [];
                    } else {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                } catch (error) {
                    console.warn('Could not load annotations for', this.currentTranscript.filename, error);
                    this.annotations = [];
                }
            }

            cancelSelection() {
                this.clearSelection();
            }

            clearSelection() {
                this.selectedMessages = [];
                this.selectionStart = null;
                this.clearSelectionDisplay();
                
                const form = document.getElementById('selectionAnnotation');
                if (form) {
                    form.style.display = 'none';
                }
                
                // Clear form inputs
                const labelInput = document.getElementById('selectionLabel');
                const descInput = document.getElementById('selectionDescription');
                if (labelInput) labelInput.value = '';
                if (descInput) descInput.value = '';
            }

            filterMessages() {
                const checkboxes = document.querySelectorAll('#filterCheckboxes input[type="checkbox"]');
                const selectedSpeakers = Array.from(checkboxes)
                    .filter(cb => cb.checked)
                    .map(cb => cb.dataset.speaker);

                const messages = document.querySelectorAll('.message');
                messages.forEach(message => {
                    const speaker = message.dataset.speaker;
                    if (selectedSpeakers.includes(speaker)) {
                        message.classList.remove('hidden');
                    } else {
                        message.classList.add('hidden');
                    }
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            highlightAnnotationMessages(messageIndices) {
                // Clear any existing highlights
                this.clearAnnotationHighlight();
                
                // Add highlight to corresponding messages
                messageIndices.forEach(index => {
                    const message = document.querySelector(`[data-message-index="${index}"]`);
                    if (message) {
                        message.classList.add('annotation-highlight');
                    }
                });
            }

            clearAnnotationHighlight() {
                const highlightedMessages = document.querySelectorAll('.message.annotation-highlight');
                highlightedMessages.forEach(message => {
                    message.classList.remove('annotation-highlight');
                });
            }

            handleAutoScroll(event) {
                const mainContent = document.querySelector('.main-content');
                if (!mainContent) return;

                const rect = mainContent.getBoundingClientRect();
                const mouseY = event.clientY;
                
                // Calculate distance from top and bottom edges
                const distanceFromTop = mouseY - rect.top;
                const distanceFromBottom = rect.bottom - mouseY;
                
                // Check if we should scroll up (near top)
                if (distanceFromTop < this.autoScrollThreshold && distanceFromTop > 0) {
                    this.startAutoScroll('up');
                }
                // Check if we should scroll down (near bottom)
                else if (distanceFromBottom < this.autoScrollThreshold && distanceFromBottom > 0) {
                    this.startAutoScroll('down');
                }
                // Stop auto-scroll if cursor is in the middle area
                else if (distanceFromTop > this.autoScrollThreshold && distanceFromBottom > this.autoScrollThreshold) {
                    this.stopAutoScroll();
                }
            }

            startAutoScroll(direction) {
                // Don't start if already scrolling in the same direction
                if (this.autoScrollInterval && this.autoScrollDirection === direction) {
                    return;
                }
                
                // Stop any existing auto-scroll
                this.stopAutoScroll();
                
                this.autoScrollDirection = direction;
                const mainContent = document.querySelector('.main-content');
                
                this.autoScrollInterval = setInterval(() => {
                    if (!this.isSelecting) {
                        this.stopAutoScroll();
                        return;
                    }
                    
                    if (direction === 'up') {
                        mainContent.scrollTop = Math.max(0, mainContent.scrollTop - this.autoScrollSpeed);
                    } else if (direction === 'down') {
                        const maxScroll = mainContent.scrollHeight - mainContent.clientHeight;
                        mainContent.scrollTop = Math.min(maxScroll, mainContent.scrollTop + this.autoScrollSpeed);
                    }
                }, 16); // ~60fps
            }

            stopAutoScroll() {
                if (this.autoScrollInterval) {
                    clearInterval(this.autoScrollInterval);
                    this.autoScrollInterval = null;
                    this.autoScrollDirection = null;
                }
            }

            async deleteAnnotation(annotationId) {
                if (!this.currentTranscript) {
                    alert('No transcript selected.');
                    return;
                }

                try {
                    const response = await fetch(`${this.apiBaseUrl}/annotations/${this.currentTranscript.filename}/${annotationId}`, {
                        method: 'DELETE',
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    console.log('Annotation deleted successfully:', result);

                    // Remove from local cache
                    this.annotations = this.annotations.filter(annotation => annotation.id !== annotationId);

                    // Refresh displays
                    this.positionAnnotations();
                    await this.updateAnnotationsSidebar();

                    return result;
                } catch (error) {
                    console.error('Error deleting annotation:', error);
                    alert('Error deleting annotation. Please check the server connection.');
                    throw error;
                }
            }

            // Helper function to remove extra whitespace from multiline template literals
            minifyHtml(html) {
                // return html.replace(/\s+/g, ' ').trim();
                return html.replace(/>\s+</g, '><').replace(/\s+/g, ' ').trim();
            }
        }

        // Initialize the application when the DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded and parsed');
            new TranscriptAnnotator();
        });
    </script>
</body>
</html>
